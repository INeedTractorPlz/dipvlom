#include<array>
#include<algorithm>
#include<cmath>
#include<limits>
#include<type_traits>

template<class Vector,int N=4>
class Lobatto3a
{
    using vector_t = std::array<long double,N>;
    using matrix_t = std::array<vector_t,N>;
    using ks_t = std::array<Vector,N>;
    vector_t a,sigma;
    matrix_t b;
    typename Vector::value_type epsilon;
    long double diffnorm(const ks_t& k1,ks_t& k2)
    {
        vector_t r;
        for(unsigned int i=0;i<k1.size();i++)
        {
            k2[i]+=-1*k1[i];
            r[i]=~k2[i];
        }
        long double res=*std::max_element(r.begin(),r.end())/norm(k1);
        return res;
    }
    long double norm(const ks_t& k)
    {
        long double r=0,t;
        for(auto x:k)
        {
            t=~x;
            if(t>r) r=t;
        }
        return r;
    }
public:
    Lobatto3a()
    {
        if constexpr (N==2)
        {
            a={0.0L, 1.0L};
            sigma={1.0L/2.0L, 1.0L/2.0L};
            b[0].fill(0.0L);
            b[1]=sigma;
        }
        else if constexpr (N==3)
        {
            a={0.0L, 1.0L/2.0L, 1.0L};
            sigma={1.0L/6.0L, 2.0L/3.0L, 1.0L/6.0L};
            b[0].fill(0.0L);
            b[1]={5.0L/24.0L, 1.0/3.0L, -1.0L/24.0L};
            b[2]=sigma;
        }
        else if constexpr (N==4)
        {
            a={0.0L, (5.0L-sqrt(5.0L))/10.0L, (5.0L+sqrt(5.0L))/10.0L, 1.0L};
            sigma={1.0L/12.0L, 5.0L/12.0L, 5.0L/12.0L, 1.0L/12.0L};
            b[0].fill(0.0L);
            b[1]={(11.0L+sqrt(5.0L))/120.0L, (25.0L-sqrt(5.0L))/120.0L, (25.0L-13.0L*sqrt(5.0L))/120.0L, (-1.0L+sqrt(5.0L))/120.0L};
            b[2]={(11.0L-sqrt(5.0L))/120.0L, (25.0L+13.0L*sqrt(5.0L))/120.0L, (25.0L+sqrt(5.0L))/120.0L, (-1.0L-sqrt(5.0L))/120.0L};
            b[3]=sigma;
        }
        else if constexpr (N==5)
        {
            a={0.0L, (7.0L-sqrt(21.0L))/14, 1.0L/2.0L, (7+sqrt(21.0L))/14.0L, 1.0L};
            sigma={1.0L/20.0L, 49.0L/180.0L, 16.0L/45.0L, 49.0L/180.0L, 1.0L/20.0L};
            b[0].fill(0.0L);
            b[1]={(119.0L+3.0L*sqrt(21.0L))/1960.0L, (343.0L-9.0L*sqrt(21.0L))/2520.0L, (392.0L-96.0L*sqrt(21.0L))/2205, (343.0L-69.0L*sqrt(21.0L))/2520.0L, (-21.0L+3.0L*sqrt(21.0L))/1960.0L};
            b[2]={13.0L/320.0L, (392.0L+105.0L*sqrt(21.0L))/2880.0L, 8.0L/45.0L, (392.0L-105*sqrt(21.0L))/2880.0L, 3.0L/320.0L};
            b[3]={(119.0L-3.0L*sqrt(21.0L))/1960.0L, (343.0L+69.0L*sqrt(21.0L))/2520.0L, (392.0L+96.0L*sqrt(21.0L))/2205.0L, (343.0L+9.0L*sqrt(21.0L))/2520.0L, -(21.0L+3.0L*sqrt(21.0L))/1960.0L};
            b[4]=sigma;
        }
        else if constexpr (N==6)
        {
            a={0.0L,1.1747233803526765357449851302033093e-1L,3.5738424175967745184292450297956046e-1L,6.4261575824032254815707549702043954e-1L,8.8252766196473234642550148697966908e-1L,1.0L};
            sigma={3.3333333333333333333333333333333333e-2L,1.8923747814892349015830640410601233e-1L,2.7742918851774317650836026256065434e-1L,2.7742918851774317650836026256065434e-1L,1.8923747814892349015830640410601233e-1L,3.3333333333333333333333333333333333e-2L};
            b[0].fill(0.0L);
            b[1]={4.5679805133755038575653446730922972e-2L,8.1867817008970666864969819153683861e-2L,-1.487460578908983676559396150555719e-2L,7.6276761182509598020429585787853333e-3L,-4.4717804405737092705509645159422079e-3L,1.6434260039545343679772145784381566e-3L};
            b[2]={2.5908385387879822499353401700632774e-2L,2.1384080863282571965204027280905642e-1L,1.3396073565086083664894428137964585e-1L,-2.4004074733154873937276256033001734e-2L,1.1807696377659694346907243344183639e-2L,-4.1293095563937473670444402209564835e-3L};
            b[3]={3.746264288972708070037777355428982e-2L,1.7742978177126379581139916076182869e-1L,3.0143326325089805044563651859365607e-1L,1.4346845286688233985941598118100849e-1L,-2.460333048390222949373386870304409e-2L,7.4249479454535108339799316327005587e-3L};
            b[4]={3.1689907329378798965356118754895177e-2L,1.9370925858949719942885736862195453e-1L,2.6980151239949221670631730398186901e-1L,2.9230379430683301327395422406621153e-1L,1.0736966113995282329333658495232847e-1L,-1.2346471800421705242320113397589639e-2L};
            b[5]=sigma;
        }
        else if constexpr (N==7)
        {
            a={0.0L,8.488805186071653506398389301626743e-2L,2.6557560326464289309811405904561684e-1L,5.0e-1L,7.3442439673535710690188594095438317e-1L,9.1511194813928346493601610698373257e-1L,1.0L};
            sigma={2.3809523809523809523809523809523809e-2L,1.3841302368078297400535020314503315e-1L,2.1587269060493131170893551114068114e-1L,2.4380952380952380952380952380952381e-1L,2.1587269060493131170893551114068114e-1L,1.3841302368078297400535020314503315e-1L,2.3809523809523809523809523809523809e-2L};
            b[0].fill(0.0L);
            b[1]={3.2846264328292647881547377380331421e-2L,5.9322894027551404504198527596713417e-2L,-1.0768594451189267105573388916275431e-2L,5.5975917805697772306731264515785011e-3L,-3.488929970807462766480046045821455e-3L,2.2170965889145396997313080577989019e-3L,-8.3827044261510438011301150805792508e-4L};
            b[2]={1.8002223201815165703973460160284566e-2L,1.5770113064168904204778906247437054e-1L,1.0235481204686191521394666173809335e-1L,-1.8478259273459043983140512247516131e-2L,9.5775801007414059542896765174719021e-3L,-5.6818645662243775729731799680753607e-3L,2.0999811132187857342288903709879644e-3L};
            b[3]={2.7529761904761904761904761904761902e-2L,1.2778825555983746958666847435455748e-1L,2.3748565272164544351033623662864482e-1L,1.2190476190476190476190476190476191e-1L,-2.1612962116714131801400725487963681e-2L,1.0624768120945504418681728790475672e-2L,-3.7202380952380952380952380952380952e-3L};
            b[4]={2.1709542696305023789580633438535843e-2L,1.4409488824700735157832338311310851e-1L,2.0629511050418990575464583462320924e-1L,2.6228778308298285350695003605703994e-1L,1.1351787855806939649498884940258779e-1L,-1.9288106960906068042438859329337396e-2L,5.8073006077086438198360636492392419e-3L};
            b[5]={2.4647794252138913903922535317581733e-2L,1.3619592709186843430561889508723425e-1L,2.1936162057573877447541555718650259e-1L,2.3821193202895403229313639735794531e-1L,2.2664128505612057881450890005695657e-1L,7.909012965323156950115167554831973e-2L,-9.0367405187688383577378535708076123e-3L};
            b[6]=sigma;
        }
//        else if constexpr (N==8)
//        {
//            a={};
//            sigma={};
//            b[0].fill(0.0L);
//            b[1]={};
//            b[2]={};
//            b[3]={};
//            b[4]={};
//            b[5]={};
//            b[6]={};
//            b[7]=sigma;
//        }
        else static_assert(true,"That N is not allowed.");
        epsilon=10*std::numeric_limits<typename Vector::value_type>::epsilon(); //1e-18;
    }
    template<class RHS>
    Vector do_step(const Vector& y,RHS rhs,const long double& t,const long double& dt)
    {
        ks_t k{};
        k.fill(Vector());
        ks_t k_prev=k;
        k_prev[0][0]++; //set initial difference to allow next cycle
        while(diffnorm(k,k_prev)>epsilon)
        {
            k_prev=k;
            for(unsigned int i=1;i<N;i++)
            {
                auto v=b[i][0]*k[0];
                for(unsigned int o=1;o<N;o++) v+=b[i][o]*k[o];
                v=dt*v;
                v+=y;
                rhs(v,k[i],t+a[i]*dt);
            }
        }
        auto v=sigma[0]*k[0];
        for(unsigned int i=1;i<N;i++) v+=sigma[i]*k[i];
        v=dt*v;
        v+=y;
        return v;
    }
};
